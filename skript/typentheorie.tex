Eine Gemeinsamkeit mit der Ihnen vertrauten Art Mathematik zu betreiben, ist, dass wir auch weiterhin Buchstaben verwenden, um komplexere Ausdrücke abzukürzen und Funktionen zu definieren - etwa ``$x\mapsto x+1$''. In der Typentheorie gibt es Terme, die wir auch Elemente nennen werden, und Typen. Ein Term hat stets einen Typ. Zum Beispiel werden wir mit ``$n:\N$'' später ausdrücke können, dass $n$ ein Term des Typs $\N$ der natürlichen Zahlen. ``$n:\N$'' ist ein \begriff{Urteil}.
In der Homotopietypentheorie gibt es vier grundlegende Urteile:

\begin{center}
  \begin{tabular}{ll}
    Urteil                        & Bedeutung \\
    \hline
    $ t : A$         & $t$ ist ein Term vom Typ $A$ \\
    $ A$ Typ         & $A$ ist ein Typ \\
    $ A\equiv B$     & $A$ und $B$ sind (urteils-)gleiche Typen \\
    $ t\equiv s : A$ & $t$ und $s$ sind (urteils-)gleiche Terme des Typs $A$ \\
  \end{tabular}
  \label{tab:urteile}
\end{center}

\subsection{Funktionen in einfacher Typentheorie}
Wir werden in diesem Abschnitt ein Fragment einer einfachen Typentheorie betrachten - ``einfach'' bedeutet hier, dass es sich noch nicht um eine abhängige Typentheorie handelt.
Typentheorien bestehen aus einer Liste von Regeln - unsere erste Regel ist:
\begin{center}
 Wenn $A$ und $B$ Typen sind, dann ist $A\to B$ ein Typ.
\end{center}
Regeln, die es erlauben neue Typen zu produzieren, werden auch \begriff{Typformer} genannt.
Das Urteil $f:A\to B$ bedeutet nun dass $f$ ein Term des Typs $A\to B$ ist (also eine Funktion).
Um Terme des Typs $A\to B$ zu konstruieren, muss unter der Annahme $x:A$ ein Term $b(x):B$ angegeben werden:
\begin{center}
  Ist unter der Annahme $x:A$ ein Term $b(x):B$ gegeben, so ist $x\mapsto b(x) : A\to B$.
\end{center}
Regeln die Terme konstruieren nennen wir \begriff{Konstruktoren}\footnote{In der literatur ``Introduction rules''.}.
Schließlich gibt es eine Regel, die es erlaubt Terme des Typs $A\to B$ zu \emph{verwenden}:
\begin{center}
  Seien $f:A\to B$ und $x:A$, dann gibt es einen Term $f(x):B$.
\end{center}
Regeln dieser Art werden \begriff{Eliminatoren} genannt.
\begin{beispiel}
\begin{enumerate}[(a)]
\item Für Typen $A,B,C$ gibt es stets eine Funktion $s$ des Typs
  \[
    (A\to (B\to C)) \to (B\to (A\to C))
  \]
  gegeben durch $f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
\item Wenn wir für einen Moment annehmen, wir hätten bereits einen Typ $\N$ der natürlichen Zahlen und $+:\N\to(\N\to \N)$ dann können wir die folgende Funktion definieren:
\begin{align*}
  d:&\N\to\N \\
    & x\mapsto x+x
\end{align*}
\end{enumerate}
\end{beispiel}

Im ersten Beispiel haben wir gesehen, dass sich Funktionen in zwei Argumenten durch iterierte Typformierung ``$A\to (B\to C)$'' ausdrücken lassen. Man beachte dass das nicht der gleiche Typ wie ``$(A\to B)\to C$'' ist.
\begin{konvention}
  Seien $A,B,C$ Typen. $A\to B\to C$ bezeichnet den Typ $A\to (B\to C)$.
\end{konvention}
Wir verwenden das Zeichen $\colonequiv$ für Definitionen.
Der Text im Beispiel entspricht also der Definition $s\colonequiv f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
Das Symbol $\colonequiv$ passt zusammen mit der definitionalen Gleichheit in der Homotopietypentheorie $\equiv$. Solche Gleichheiten bekommen wir mit den folgenden Regeln:
\begin{center}
  Für $b(x):B$ unter der Annahme $x:A$ und $a:A$ gilt $(x\mapsto b(x))(a)\equiv b(a)$.
\end{center}
Regeln, die auf diese Art Konstruktoren und Eliminatoren verbinden heißen \begriff{Berechnungsregeln}\footnote{In der Literatur ``computation rules''.}
Speziell für Funktionen gibt es noch die sogenannte ``$\eta$-rule'':
\begin{center}
  Für $f:A\to B$ gilt $f\equiv x\mapsto f(x)$.
\end{center}

Wir kommen nun zu unseren ersten Definitionen:
\begin{definition}
  Sei $A$ ein Typ. Dann bezeichnen wir den Term $x\mapsto x:A\to A$ mit $\id_A$.
\end{definition}

\begin{definition}
  Seien $A,B,C$ Typen. Dann ist $\circ:(B\to C)\to (A\to B) \to (A\to C)$ gegeben durch
  \[
    g\mapsto (f\mapsto (x\mapsto g(f(x))))
  \]
  Wir schreiben wie gewohnt $g\circ f$ statt $\circ(g)(f)$.
\end{definition}

\begin{bemerkung}
\begin{enumerate}
\item Für $h:A\to B$ gilt stets $h\circ \id_A\equiv h\equiv \id_B\circ h$.
  Das lässt sich durch auffalten der Definitionen von ``$\circ$'' und ``$\id_A$'', mehrfaches Anwenden der Berechnungsregel und schließlich einer Anwendung der $\eta$-Regel zeigen - wir zeigen nur $h\circ \id_A\equiv h$:
  \begin{align*}
    h\circ \id_A &\equiv (g\mapsto (f\mapsto (x\mapsto g(f(x)))))(h)(\id_A) \\
    &\equiv (f\mapsto (x\mapsto h(f(x))))(\id_A) \\
    &\equiv x\mapsto h(\id_A(x)) \\
    &\equiv x\mapsto h((y\mapsto y)(x)) \\
    &\equiv x\mapsto h(x) \\
    &\equiv h
  \end{align*}
\item In den Übungen werden wir sehen: $h \circ (g\circ f)\equiv (h\circ g)\circ f$.
\end{enumerate}
\end{bemerkung}

\subsection{Abhängige Funktionen}
Wir wollen nun die Regeln des letzten Abschnitts verallgemeinern.
Dafür gibt es verschiedene Gründe. Der wichtigste ist, dass wir Prädikate in der Typentheorie haben wollen und einen verallgemeinerten Funktionstyp als $\forall$-quantor verwenden wollen.

Ein abhängiger Typ ist nichts weiter als ein Ausdruck $B(x)$, der unter der Annahme $x:A$ ein Typ ist.

\begin{beispiel}
  Wir greifen etwas vorweg um konkrete Beispiele zu geben.
  Für $n:\N$ werden wir noch einen Typ $L(n)$ der Listen der Länge $n$ von natürlichen Zahlen konstruieren. Weiter wird es später auch möglich sein, etwa den Typ der Teiler einer natürlichen Zahl zu definieren. Oder einen Typ, der genau dann Terme hat, wenn eine natürliche Zahl eine andere teilt.
\end{beispiel}

Die Regeln für Funktionstypen aus dem letzten Abschnitt lassen sich nun wie folgt für \begriff{abhängige Funktionen} verallgemeinern:

\begin{regeln}
\begin{itemize}
\item Sei für $x:A$ ein Typ $B(x)$ gegeben, dann ist $(x:A)\to B(x)$\index{$(x:A)\to B(x)$} ein Typ. 
\item Sei für $x:A$ ein Term $b(x):B(x)$ gegeben, dann ist $x\mapsto b(x) : (x:A)\to B(x)$\index{$x\mapsto b(x)$}. 
\item Für $f:(x:A)\to B(x)$ und $a:A$ gibt es $f(a):B(a)$. 
\item Sei für $x:A$ ein Term $b(x):B(x)$ gegeben und $a:A$, dann $(x\mapsto b(x))(a)\equiv b(a)$. 
\item Für $f:(x:A)\to B(x)$ ist $(x\mapsto f(x))\equiv f$.
\end{itemize}
\end{regeln}

Statt $(x:A)\to B(x)$ schreiben wir auch $\prod_{x:A}B(x)$.
Falls $B(x)$ konstant ein Typ $C$ ist, schreiben wir auch $A\to C$ und sind damit kompatibel zum vorangegangenen Abschnitt.
Außerdem ist es manchmal hilfreich mehr Typen anzugeben als unbedingt notwendig - zum Beispiel hilft es zur Lesbarkeit den Typ der Variable in Funktionsausdrücken anzugeben: $(x:A)\mapsto b(x)$\index{$(x:A)\mapsto b(x)$}.

\subsection{Natürliche Zahlen}
Ähnlich wie bei dem Funktionstyp beschreiben wir die natürlichen Zahlen auch darüber, wie man Elemente erzeugen und verwenden kann.
Die Formierungsregel ist denkbar einfach: Es gibt einen Typ $\N$\index{$\N$}.

Die \begriff{natürlichen Zahlen} $\N$ haben \emph{zwei} Konstruktoren:
\begin{center}
\begin{tabular}{l}
  Es gibt $0:\N$. \\
  Für jedes $n:\N$ gibt es einen Nachfolger $S(n):\N$\index{$S(n)$}.
\end{tabular}
\end{center}
Dass wir hier ``Nachfolger'' schreiben hat keine formale Bedeutung.
\begin{beispiel}
Wir können nun natürliche Zahlen angeben: $0$, $1\colonequiv S(0)$, $2\colonequiv S(1)$, \dots.
\end{beispiel}
Der Eliminator ist auf den ersten Blick vielleicht etwas undurchsichtig, wird aber sicher schnell klarer durch Beispiele:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$ und $p_S:(x:\N)\to (P(x)\to P(S(x)))$ dann gibt es
  $\elim_\N(p_0,p_S):(x:\N)\to P(x)$.
\end{center}
Wir betrachten zunächst den Fall, dass $P(x)$ konstant ein Typ $A$ ist.
Dann sind die ``Eingangsdaten'' für den Eliminator ein $a:A$ und eine Funktion $\N\to (A\to A)$.
In diesem Fall spricht man auch von \begriff{Rekursion}.
Wenn man eine Funktion $f:\N\to A$ durch Rekursion definiert, gibt man üblicherweise an, was im Fall $n\equiv 0$ passiert und wie man aus $f(n)$ den nächsten Wert $f(n+1)$ konstruiert.
Diese beiden Fälle entsprechen genau den Daten $a:A$ und $r:\N\to (A\to A)$.
\begin{beispiel}
  Wir können Verdopplung $d:\N\to \N$ von natürlichen Zahlen definieren durch:
  \[d\colonequiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))\rlap{.}\]
\end{beispiel}
Um die soeben definierte Funktion testen zu können, benötigen wir die Berechnungsregel für $\N$:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$, $p_S:(x:\N)\to (P(x)\to P(S(x)))$ und $n:\N$
  dann gelten $\elim_\N(p_0,p_S)(0)\equiv p_0$ und $\elim_\N(p_0,p_S)(S(n))\equiv p_S(n)(\elim_\N(p_0,p_S)(n))$.
\end{center}
Damit können wir nun zum Beispiel berechnen:
\begin{align*}
  d(2)&\equiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(1)) \\
      &\equiv (n\mapsto (k\mapsto S(S(k))))(1)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))) \\
      &\equiv (k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(1)) \\
      &\equiv S(S(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(0)))) \\
      &\equiv S(S((n\mapsto (k\mapsto S(S(k))))(0)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S((k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S(S(S(0)))) \\
      &\equiv 4
\end{align*}

Um definitionen übersichtlicher darzustellen, verwenden wir \begriff{Pattern-matching}:

\begin{konvention}
\begin{enumerate}[(a)]
\item Definitionen der Form $f\colonequiv x\mapsto b(x)$ erlauben wir uns von nun an auch als
  \begin{align*}
    f(x)\colonequiv b(x)
  \end{align*}
  zu schreiben. 
\item Definitionen wie in obigem Beispiel schreiben wir auch in der folgenden Form
  \begin{align*}
    d(0)&\colonequiv 0 \\
    d(S(n))&\colonequiv S(S(d(n))) 
  \end{align*}
  - wenn die Übersetzung in Eliminatoraufrufe klar ist.
  Diese Form einer Definition nennen wir \begriff{Pattern-Matching}.
\item (a) und (b) dürfen kombiniert werden, wie in der folgenden Definition von ``$+$''.
\end{enumerate}
\end{konvention}

Nun wählen wir $\N\to\N$ für den Zieltyp im Eliminator um die Addition zu definieren.
Wie bei der Komposition ``$\circ$'' wollen wir eine Operatorschreibweise verwenden.
Wir geben von nun an durch Unterstriche vor, wo die Argumente eines Operators stehen sollen (``$\_+\_$'' unten) und verwenden die Operatorschreibweise direkt in der Definition.
\begin{definition}
  Die Funktion $\_+\_:\N\to (\N\to \N)$ ist gegeben durch
  \begin{align*}
    \_+\_:&\N\to (\N\to \N) \\
      0+n&\colonequiv n \\
     S(n)+k&\colonequiv S(n+k)
  \end{align*}
\end{definition}

\begin{bemerkung}
  Per Definition gilt $0+n\equiv n$, aber wir können nicht erwarten, dass auch $n+0\equiv n$ gilt.
  Um die üblichen Gesetze der Addition auf den natürlichen Zahlen zu zeigen, brauchen wir die Objektgleichheit ``$=$'', die wir später einführen werden.
\end{bemerkung}

\subsection{Weitere induktive Typen}
Die natürlichen Zahlen wie sie im letzten Abschnitt eingeführt wurden, sind ein Spezialfall eines
\begriff{induktiven Typen}s. In diesem Abschnitt werden wir weitere Beispiele kennen lernen.

Der \begriff{Einstyp} $\mathbf{1}$\index{$\mathbf{1}$} hat einen Konstruktor ohne Argumente.
Daraus ergeben sich die folgenden Regeln:

\begin{regeln}
\begin{itemize}
\item Es gibt den Typ $\mathbf{1}$. 
\item Es gibt $\ast:\mathbf{1}$. 
\item Für einen Typ $A(x)$ unter der Annahme $x:\mathbf{1}$ und $a:A(\ast)$
gibt es $\elim_{\mathbf{1}}(a):(x:\mathbf{1})\to A(x)$.
\item Für einen Typ $A(x)$ unter der Annahme $x:\mathbf{1}$ und $a:A(\ast)$
gilt $\elim_{\mathbf{1}}(a)(\ast)\equiv a$.
\end{itemize}
\end{regeln}

Ein noch minimalerer Fall ist der \begriff{leere Typ} $\emptyset$\index{$\emptyset$},
der keinen Konstruktor hat und damit nur zwei Regeln:

\begin{regeln}
\begin{itemize}
\item Es gibt den Typ $\emptyset$. 
\item Sei $A(x)$ ein Typ für $x:\emptyset$, dann gibt es $\elim_\emptyset:(x:\emptyset)\to A(x)$.
\end{itemize}
\end{regeln}

Es ist möglich, Typen als Parameter für induktive Definitionen zu verwenden.
Ein wichtiges Beispiel, das uns noch begleiten wird, ist das \begriff{Koprodukt} $A\sqcup B$\index{$A\sqcup B$}, das ein induktiver Typ mit zwei Konstruktoren ist.

\begin{regeln}
Seien $A,B$ Typen.
\begin{itemize}
\item Es gibt den Typ $A\sqcup B$.
\item Für jedes $a:A$ gibt es $\iota_1(a):A\sqcup B$.
  Und für jedes $b:B$ gibt es $\iota_2(b):A\sqcup B$.
\item Sei $P(x)$ ein Typ für $x:A\sqcup B$.
  Für $p_1:(y:A)\to P(\iota_1(y))$ und $p_2:(z:A)\to P(\iota_2(z))$
  gibt es $\elim_\sqcup(p_1,p_2):(x:A\sqcup B)\to P(x)$.
\item Sei $P(x)$ ein Typ für $x:A\sqcup B$.
  Für $p_1:(y:A)\to P(\iota_1(y))$ und $p_2:(z:A)\to P(\iota_2(z))$
  gilt $\elim_\sqcup(p_1,p_2)(\iota_1(y))\equiv p_1(y)$ für $y:A$
  und  $\elim_\sqcup(p_1,p_2)(\iota_2(z))\equiv p_1(z)$ für $z:B$.
\end{itemize}
\end{regeln}

\begin{bemerkung}
Sei $A$ ein Typ. Es gibt Funktionen
  \begin{align*}
    \varphi: &A\to \emptyset\sqcup A &\psi:\emptyset\sqcup A \to A \\
    \varphi(a)&\colonequiv \iota_2(a) &\psi(\iota_2(a))\colonequiv a 
\end{align*}
Die Pattern-Matching-Definition auf der rechten Seite ist vollständig, weil wir im Fall ``$\iota_1$'' auf den leeren Typ matchen und damit null Fälle zu klären haben.
\end{bemerkung}

\subsection{Gleichheit}
\begin{konvention}
\begin{enumerate}[(a)]
\item Statt $f(x)(y)$ schreiben wir auch $f(x,y)$.
\item Typformer für Induktive Typen binden stärker als ``$\to$''. Wir können als zum Beispiel $A\to B\sqcup C$'' schreiben für Funktionen in ein Koprodukt.
\item Wir sagen nun auch gelegentlich, dass wir \begriff{Induktion} verwenden und meinen damit, dass wir den Eliminator eines induktiven Typs verwenden.
\end{enumerate}
\end{konvention}

Für die Addition auf den natürlichen Zahlen $\N$ gilt per definition für alle $n:\N$:
\[
  0+n\equiv n
\]
Jedoch ist es nicht möglich $n+0\equiv n$ zu zeigen, auch wenn wir für jedes konkrete $k:\N$ wie zum Beispiel 17 sehr wohl zeigen können, dass diese Urteilsgleichheit gilt.
Wir können die Induktion nicht auf das Problem $n+0\equiv n$ anwenden, da es sich dabei nicht um einen abhängigen Typen, sondern um ein Urteil handelt.

Wir wollen uns nun der eigentlichen Gleichheit zuwenden und von nun an mit ``gleich'' die im folgenden eingeführte Gleichheit meinen und nicht die Urteilsgleichheit.
Die Gleichheit in der Homotopietypentheorie ist ein Typ, der nur für zwei Terme des gleichen Typs überhaupt geformt werden kann.
So können wir etwa Fragen, ob zwei natürliche Zahlen gleich sind -- und in diesem Fall wird sich auch herausstellen, dass das eine entscheidbare Frage ist.

Am Ende des letzten Abschnitts hatten wir bereits gesehen, dass Typen von anderen Typen abhängen können. Gleichheit ist ein Typ, der von \emph{Termen} eines Typs abhängt.
Wir werden nun die Regeln für Gleichheit vorstellen und danach im Einzelnen erklären.

\begin{regeln}
\begin{itemize}
\item Sei $A$ ein Typ und seinen weiter $x,y:A$. Dann ist $x=_Ay$\index{$x=_Ay$} ein Typ -- der \begriff{Gleichheitstyp}. Zur Abgrenzung von Urteilsgleichheit sprechen wir hier auch vom \begriff{Identitätstyp} oder \begriff{Objektgleichheit}\footnote{In der Literatur sind noch verbreitet: ``Propositional equality'', ``Paths'' und ``Typal equality''}. Wir schreiben manchmal auch nur $x=y$.
\item Für $x:A$ gibt es $\refl_x:x=_Ax$\index{$\refl_x$}. Wir schreiben auch einfach $\refl$\index{$\refl$}.
\item Sei $P(x,y,\gamma)$ ein Typ für $x,y:A$ und $\gamma:x=_Ay$.
  Für $p_{x}:P(x,x,\refl_x)$ gibt es
  \[
    \elim_{=,P}:(x\ y : A) \to (\gamma : x=_Ay) \to P(x,y,\gamma)\rlap{.}
  \]
\item \dots und es gilt $\elim_=(x,x,\refl_x)\equiv p_x$.
\end{itemize}
\end{regeln}

Der Eliminator wird auch Gleichheitsinduktion oder ``J-Rule'' genannt -- wir wollen uns für diesen Eliminator die Option lassen, das Motiv, $P$ im Index mit anzugeben.
In Worten sagt dieser inetwa, dass es genug ist eine Konstruktion, die eine Gleichheit verwendet, für die reflexive Gleichheit ``$\refl_x:x=x$'' anzugeben.
Umso erstaunlicher ist es, dass es möglich ist, diese Gleichheiten als Pfade in Räumen zu interpretieren. Wir werden immer mal wieder auf diese Sicht eingehen.

Wir können nun Aussagen über die induktiven Typen aus dem vorangegangenen Abschnitt machen.
\begin{bemerkung}
  Für jedes $x:\eins$ gilt $x=\ast$.
  Damit meinen wir, dass es einen Term des Typs $(x:\eins)\to x=\ast$ gibt.
\end{bemerkung}
\begin{beweis}
  Wir verwenden den Eliminator für $\eins$.
  Als Motiv verwenden wir $P(x)\colonequiv x=\ast$. Also müssen wir, um $(x:\eins)\to P(x)$ zu zeigen einen Term $P(\ast)$ finden. Der ist durch $\refl_\ast$ gegeben. 
\end{beweis}

\begin{bemerkung}
  Sei $\zwei$ analog zu $\eins$ definiert, mit Konstruktoren $0_\zwei$ und $1_\zwei$.
  Dann gilt $(x:\zwei)\to (x=0_\zwei)\sqcup (x=1_\zwei)$.
\end{bemerkung}
\begin{beweis}
  Wir müssen ein Element des Typs $(x=0_\zwei)\sqcup (x=1_\zwei)$ prozieren.
  Mit dem Eliminator, reicht es das für die Fälle $0_\zwei$ und $1_\zwei$ zu machen.
  Das ist mit den Termen $\iota_1(\refl_{0_\zwei})$ und $\iota_2(\refl_{1_\zwei})$ erledigt.
\end{beweis}

Nun werden wir einige allgemeine Operationen auf Gleichheitstypen konstruieren.
Die folgenden zwei Operationen können einerseits als die übliche Symmetrie und Transitivität von Äquivalenzrelationen gesehen werden, aber auch als Umdrehen und Aneinanderhängen von Pfaden in einem Raum.

\begin{definition}
  Seien $A$ ein Typ und $x,y:A$.
  Die \begriff{Inversion}\index{$\_^{-1}$} von Gleichheiten ist gegeben durch
  \begin{align*}
    \_^{-1} &: x=_Ay\to y=_Ax \\
    \refl_x^{-1}&\colonequiv \refl_x 
  \end{align*}
  Wir können diese Definition mit dem Eliminator äquivalent wie folgt angeben ($P(x,y,\gamma)$ ist hier $y=_Ax$):
  \[
     \_^{-1}\colonequiv \elim_=((x:A) \mapsto \refl_x)\rlap{.}
  \]
\end{definition}

\begin{definition}
  Seien $A$ ein Typ und $x,y,z:A$.
  Die \begriff{Konkatenation} von Gleichheiten ist gegeben durch
  \begin{align*}
    \_\kon\_&:x=y\to y=z\to x=z \\
    \refl_x\kon\gamma &\colonequiv \gamma
  \end{align*}
  Als Eliminator: $\_\kon\_\colonequiv \elim_=((x:A)\mapsto \id_{x=z})$.
\end{definition}

In der klassischen Mathematik ist es klar, dass Funktionen Gleichheit erhalten -- in der Typentheorie müssen wir das zeigen.
Genauer gesagt, wollen wir eine Operation definieren, die Gleichheiten zwischen zwei Werten auf Gleichheiten zwischen den Bildern abbildet.
Diese Operation wird typischerweise mit ``$\ap$'' wie ``application'' bezeichnet, weil man eine Funktion auf Gleichheiten anwendet. 
Wir wollen das auch direkt in der Schreibweise ausdrücken und $f(\gamma)$ für eine Funktion $f:A\to B$ und eine Gleichheit $\gamma:x=y$ schreiben.

\begin{definition}\index{$\ap_f$}
  Seien $f:A\to B$ eine Funktion $x,y:A$ und $\gamma:x=_Ay$.
  Dann ist
  \begin{align*}
    f(\_) &: x=_Ay\to f(x)=_Bf(y) \\
    f(\refl_x)&\colonequiv \refl_{f(x)}
  \end{align*}
  die Anwendung von $f$ auf $\gamma$. Wir schreiben auch $\ap_f$ für $f(\_)$.
\end{definition}

Nun können wir mehr konkrete Gleichheiten zeigen.

\begin{lemma}
\begin{enumerate}[(a)]
\item Für alle $n:\N$ gilt $n+0=n$ und $0+n=n$.
\item Für alle $n,k:\N$ gilt $n+k=k+n$.
\item Für alle $n,k,l:\N$ gilt $(n+k)+l=n+(k+l)$.
\end{enumerate}
\end{lemma}
\begin{beweis}
\begin{enumerate}[(a)]
\item Die zweite Gleichung gilt per Definition von $+$,
  für die erste, $n+0=n$, verwenden wir Induktion.
  Per Definition von $+$ haben wir $0+0\equiv 0$ und können diesen Fall somit durch $\refl_0$ klären.
  Es bleit also ein Term in $S(n)+0=S(n)$ zu konstruieren, wobei wir $\gamma:n+0=n$ verwenden dürfen.
  Per Definition von $+$ ist $S(n)+0\equiv S(n+0)$, womit unser Ziel eigentlich $S(n+0)=S(n)$ ist.
  Das bekommen wir jetzt durch Anwenden der Funktion $S$ auf die Gleichheit $\gamma$, i.e.\ $S(\gamma):S(n+0)=S(n)$.
\item Wir zeigen zunächst: Für alle $n,k:\N$ haben wir $\gamma_{n,k}S(n+k)=n+S(k)$.
  Wir verwenden Induktion über $n$.
  Für den ersten Fall müssen wir $S(0+k)=0+S(k)\equiv S(k)$ zeigen, wofür wir (a) verwenden können.
  Für $S(S(n)+k)=S(n)+S(k)$,
  was mit den Urteilsgleichheiten der Definition von $+$ zu $S(S(n+k))=S(n+S(k))$ wird,
  wenden wir auf die ``Induktionsvoraussetzung'' $S(n+k)=n+S(k)$ die Funktion $S$ an.

  Nun zur eigentlichen Gleichung $n+k=k+n$.
  Wir verwenden wieder Induktion über $n$.
  Der Fall für $0$ ist $k=k+0$, was durch Inversion aus (a) hervor geht.
  Für den Fall $S(n+k)=k+S(n)$ wenden wir zunächst $S$
  auf die Induktionvoraussetzung an um $\zeta:S(n+k)=S(k+n)$ zu bekommen.
  Damit ist $\zeta\kon\gamma_{k,n}$ eine Lösung.
\item Wird eine Aufgabe auf Übungsblatt 2 sein.
\end{enumerate}
\end{beweis}
