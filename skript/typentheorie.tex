Eine Gemeinsamkeit mit der Ihnen vertrauten Art Mathematik zu betreiben, ist, dass wir auch weiterhin Buchstaben verwenden, um komplexere Ausdrücke abzukürzen und Funktionen zu definieren - etwa ``$x\mapsto x+1$''. In der Typentheorie gibt es Terme, die wir auch Elemente nennen werden, und Typen. Ein Term hat stets einen Typ. Zum Beispiel werden wir mit ``$n:\N$'' später ausdrücke können, dass $n$ ein Term des Typs $\N$ der natürlichen Zahlen. ``$n:\N$'' ist ein \begriff{Urteil}.
In der Homotopietypentheorie gibt es vier grundlegende Urteile:

\begin{center}
  \begin{tabular}{ll}
    Urteil                        & Bedeutung \\
    \hline
    $ t : A$         & $t$ ist ein Term vom Typ $A$ \\
    $ A$ Typ         & $A$ ist ein Typ \\
    $ A\equiv B$     & $A$ und $B$ sind (urteils-)gleiche Typen \\
    $ t\equiv s : A$ & $t$ und $s$ sind (urteils-)gleiche Terme des Typs $A$ \\
  \end{tabular}
  \label{tab:urteile}
\end{center}

\subsection{Funktionen in einfacher Typentheorie}
Wir werden in diesem Abschnitt ein Fragment einer einfachen Typentheorie betrachten - ``einfach'' bedeutet hier, dass es sich noch nicht um eine abhängige Typentheorie handelt.
Typentheorien bestehen aus einer Liste von Regeln - unsere erste Regel ist:
\begin{center}
 Wenn $A$ und $B$ Typen sind, dann ist $A\to B$ ein Typ.
\end{center}
Regeln, die es erlauben neue Typen zu produzieren, werden auch \begriff{Typformer} genannt.
Das Urteil $f:A\to B$ bedeutet nun dass $f$ ein Term des Typs $A\to B$ ist (also eine Funktion).
Um Terme des Typs $A\to B$ zu konstruieren, muss unter der Annahme $x:A$ ein Term $b(x):B$ angegeben werden:
\begin{center}
  Ist unter der Annahme $x:A$ ein Term $b(x):B$ gegeben, so ist $x\mapsto b(x) : A\to B$.
\end{center}
Regeln die Terme konstruieren nennen wir \begriff{Konstruktoren}\footnote{In der literatur ``Introduction rules''.}.
Schließlich gibt es eine Regel, die es erlaubt Terme des Typs $A\to B$ zu \emph{verwenden}:
\begin{center}
  Seien $f:A\to B$ und $x:A$, dann gibt es einen Term $f(x):B$.
\end{center}
Regeln dieser Art werden \begriff{Eliminatoren} genannt.
\begin{beispiel}
\begin{enumerate}[(a)]
\item Für Typen $A,B,C$ gibt es stets eine Funktion $s$ des Typs
  \[
    (A\to (B\to C)) \to (B\to (A\to C))
  \]
  gegeben durch $f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
\item Wenn wir für einen Moment annehmen, wir hätten bereits einen Typ $\N$ der natürlichen Zahlen und $+:\N\to(\N\to \N)$ dann können wir die folgende Funktion definieren:
\begin{align*}
  d:&\N\to\N \\
    & x\mapsto x+x
\end{align*}
\end{enumerate}
\end{beispiel}

Im ersten Beispiel haben wir gesehen, dass sich Funktionen in zwei Argumenten durch iterierte Typformierung ``$A\to (B\to C)$'' ausdrücken lassen. Man beachte dass das nicht der gleiche Typ wie ``$(A\to B)\to C$'' ist.
\begin{konvention}
  Seien $A,B,C$ Typen. $A\to B\to C$ bezeichnet den Typ $A\to (B\to C)$.
\end{konvention}
Wir verwenden das Zeichen $\colonequiv$ für Definitionen.
Der Text im Beispiel entspricht also der Definition $s\colonequiv f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
Das Symbol $\colonequiv$ passt zusammen mit der definitionalen Gleichheit in der Homotopietypentheorie $\equiv$. Solche Gleichheiten bekommen wir mit den folgenden Regeln:
\begin{center}
  Für $b(x):B$ unter der Annahme $x:A$ und $a:A$ gilt $(x\mapsto b(x))(a)\equiv b(a)$.
\end{center}
Regeln, die auf diese Art Konstruktoren und Eliminatoren verbinden heißen \begriff{Berechnungsregeln}\footnote{In der Literatur ``computation rules''.}
Speziell für Funktionen gibt es noch die sogenannte ``$\eta$-rule'':
\begin{center}
  Für $f:A\to B$ gilt $f\equiv x\mapsto f(x)$.
\end{center}

Wir kommen nun zu unseren ersten Definitionen:
\begin{definition}
  Sei $A$ ein Typ. Dann bezeichnen wir den Term $x\mapsto x:A\to A$ mit $\id_A$.
\end{definition}

\begin{definition}
  Seien $A,B,C$ Typen. Dann ist $\circ:(B\to C)\to (A\to B) \to (A\to C)$ gegeben durch
  \[
    g\mapsto (f\mapsto (x\mapsto g(f(x))))
  \]
  Wir schreiben wie gewohnt $g\circ f$ statt $\circ(g)(f)$.
\end{definition}

\begin{bemerkung}
\begin{enumerate}
\item Für $h:A\to B$ gilt stets $h\circ \id_A\equiv h\equiv \id_B\circ h$.
  Das lässt sich durch auffalten der Definitionen von ``$\circ$'' und ``$\id_A$'', mehrfaches Anwenden der Berechnungsregel und schließlich einer Anwendung der $\eta$-Regel zeigen - wir zeigen nur $h\circ \id_A\equiv h$:
  \begin{align*}
    h\circ \id_A &\equiv (g\mapsto (f\mapsto (x\mapsto g(f(x)))))(h)(\id_A) \\
    &\equiv (f\mapsto (x\mapsto h(f(x))))(\id_A) \\
    &\equiv x\mapsto h(\id_A(x)) \\
    &\equiv x\mapsto h((y\mapsto y)(x)) \\
    &\equiv x\mapsto h(x) \\
    &\equiv h
  \end{align*}
\item In den Übungen werden wir sehen: $h \circ (g\circ f)\equiv (h\circ g)\circ f$.
\end{enumerate}
\end{bemerkung}

\subsection{Abhängige Funktionen}
Wir wollen nun die Regeln des letzten Abschnitts verallgemeinern.
Dafür gibt es verschiedene Gründe. Der wichtigste ist, dass wir Prädikate in der Typentheorie haben wollen und einen verallgemeinerten Funktionstyp als $\forall$-quantor verwenden wollen.

Ein abhängiger Typ ist nichts weiter als ein Ausdruck $B(x)$, der unter der Annahme $x:A$ ein Typ ist.

\begin{beispiel}
  Wir greifen etwas vorweg um konkrete Beispiele zu geben.
  Für $n:\N$ werden wir noch einen Typ $L(n)$ der Listen der Länge $n$ von natürlichen Zahlen konstruieren. Weiter wird es später auch möglich sein, etwa den Typ der Teiler einer natürlichen Zahl zu definieren. Oder einen Typ, der genau dann Terme hat, wenn eine natürliche Zahl eine andere teilt.
\end{beispiel}

Die Regeln für Funktionstypen aus dem letzten Abschnitt lassen sich nun wie folgt für \begriff{abhängige Funktionen} verallgemeinern:

\begin{regeln}
\begin{itemize}
\item Sei für $x:A$ ein Typ $B(x)$ gegeben, dann ist $(x:A)\to B(x)$\index{$(x:A)\to B(x)$} ein Typ. 
\item Sei für $x:A$ ein Term $b(x):B(x)$ gegeben, dann ist $x\mapsto b(x) : (x:A)\to B(x)$\index{$x\mapsto b(x)$}. 
\item Für $f:(x:A)\to B(x)$ und $a:A$ gibt es $f(a):B(a)$. 
\item Sei für $x:A$ ein Term $b(x):B(x)$ gegeben und $a:A$, dann $(x\mapsto b(x))(a)\equiv b(a)$. 
\item Für $f:(x:A)\to B(x)$ ist $(x\mapsto f(x))\equiv f$.
\end{itemize}
\end{regeln}

Statt $(x:A)\to B(x)$ schreiben wir auch $\prod_{x:A}B(x)$.
Falls $B(x)$ konstant ein Typ $C$ ist, schreiben wir auch $A\to C$ und sind damit kompatibel zum vorangegangenen Abschnitt.
Außerdem ist es manchmal hilfreich mehr Typen anzugeben als unbedingt notwendig - zum Beispiel hilft es zur Lesbarkeit den Typ der Variable in Funktionsausdrücken anzugeben: $(x:A)\mapsto b(x)$\index{$(x:A)\mapsto b(x)$}.

\subsection{Natürliche Zahlen}
Ähnlich wie bei dem Funktionstyp beschreiben wir die natürlichen Zahlen auch darüber, wie man Elemente erzeugen und verwenden kann.
Die Formierungsregel ist denkbar einfach: Es gibt einen Typ $\N$\index{$\N$}.

Die \begriff{natürlichen Zahlen} $\N$ haben \emph{zwei} Konstruktoren:
\begin{center}
\begin{tabular}{l}
  Es gibt $0:\N$. \\
  Für jedes $n:\N$ gibt es einen Nachfolger $S(n):\N$\index{$S(n)$}.
\end{tabular}
\end{center}
Dass wir hier ``Nachfolger'' schreiben hat keine formale Bedeutung.
\begin{beispiel}
Wir können nun natürliche Zahlen angeben: $0$, $1\colonequiv S(0)$, $2\colonequiv S(1)$, \dots.
\end{beispiel}
Der Eliminator ist auf den ersten Blick vielleicht etwas undurchsichtig, wird aber sicher schnell klarer durch Beispiele:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$ und $p_S:(x:\N)\to (P(x)\to P(S(x)))$ dann gibt es
  $\elim_\N(p_0,p_S):(x:\N)\to P(x)$.
\end{center}
Wir betrachten zunächst den Fall, dass $P(x)$ konstant ein Typ $A$ ist.
Dann sind die ``Eingangsdaten'' für den Eliminator ein $a:A$ und eine Funktion $\N\to (A\to A)$.
In diesem Fall spricht man auch von \begriff{Rekursion}.
Wenn man eine Funktion $f:\N\to A$ durch Rekursion definiert, gibt man üblicherweise an, was im Fall $n\equiv 0$ passiert und wie man aus $f(n)$ den nächsten Wert $f(n+1)$ konstruiert.
Diese beiden Fälle entsprechen genau den Daten $a:A$ und $r:\N\to (A\to A)$.
\begin{beispiel}
  Wir können Verdopplung $d:\N\to \N$ von natürlichen Zahlen definieren durch:
  \[d\colonequiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))\rlap{.}\]
\end{beispiel}
Um die soeben definierte Funktion testen zu können, benötigen wir die Berechnungsregel für $\N$:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$, $p_S:(x:\N)\to (P(x)\to P(S(x)))$ und $n:\N$
  dann gelten $\elim_\N(p_0,p_S)(0)\equiv p_0$ und $\elim_\N(p_0,p_S)(S(n))\equiv p_S(n)(\elim_\N(p_0,p_S)(n))$.
\end{center}
Damit können wir nun zum Beispiel berechnen:
\begin{align*}
  d(2)&\equiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(1)) \\
      &\equiv (n\mapsto (k\mapsto S(S(k))))(1)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))) \\
      &\equiv (k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(1)) \\
      &\equiv S(S(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(0)))) \\
      &\equiv S(S((n\mapsto (k\mapsto S(S(k))))(0)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S((k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S(S(S(0)))) \\
      &\equiv 4
\end{align*}

Um definitionen übersichtlicher darzustellen, verwenden wir \begriff{Pattern-matching}:

\begin{konvention}
\begin{enumerate}[(a)]
\item Definitionen der Form $f\colonequiv x\mapsto b(x)$ erlauben wir uns von nun an auch als
  \begin{align*}
    f(x)\colonequiv b(x)
  \end{align*}
  zu schreiben. 
\item Definitionen wie in obigem Beispiel schreiben wir auch in der folgenden Form
  \begin{align*}
    d(0)&\colonequiv 0 \\
    d(S(n))&\colonequiv S(S(d(n))) 
  \end{align*}
  - wenn die Übersetzung in Eliminatoraufrufe klar ist.
  Diese Form einer Definition nennen wir \begriff{Pattern-Matching}.
\item (a) und (b) dürfen kombiniert werden, wie in der folgenden Definition von ``$+$''.
\end{enumerate}
\end{konvention}

Nun wählen wir $\N\to\N$ für den Zieltyp im Eliminator um die Addition zu definieren.
Wie bei der Komposition ``$\circ$'' wollen wir eine Operatorschreibweise verwenden.
Wir geben von nun an durch Untertriche vor, wo die Argumente eines Operators stehen sollen (``$\_+\_$'' unten) und verwenden die Operatorschreibweise direkt in der Definition.
\begin{definition}
  Die Funktion $\_+\_:\N\to (\N\to \N)$ ist gegeben durch
  \begin{align*}
    \_+\_:&\N\to (\N\to \N) \\
      0+n&\colonequiv n \\
     S(n)+k&\colonequiv S(n+k)
  \end{align*}
\end{definition}

\begin{bemerkung}
  Per Definition gilt $0+n\equiv n$, aber wir können nicht erwarten, dass auch $n+0\equiv n$ gilt.
  Um die üblichen Gesetze der Addition auf den natürlichen Zahlen zu zeigen, brauchen wir die Objektgleichheit ``$=$'', die wir später einführen werden.
\end{bemerkung}

\subsection{Weitere induktive Typen}
Die natürlichen Zahlen wie sie im letzten Abschnitt eingeführt wurden, sind ein Spezialfall eines
\begriff{induktiven Typen}s. In diesem Abschnitt werden wir weitere Beispiele kennen lernen.

Der \begriff{Einstyp} $\mathbf{1}$\index{$\mathbf{1}$} hat einen Konstruktor ohne Argumente.
Daraus ergeben sich die folgenden Regeln:

\begin{regeln}
\begin{itemize}
\item Es gibt den Typ $\mathbf{1}$. 
\item Es gibt $\ast:\mathbf{1}$. 
\item Für einen Typ $A(x)$ unter der Annahme $x:\mathbf{1}$ und $a:A(\ast)$
gibt es $\elim_{\mathbf{1}}(a):(x:\mathbf{1})\to A(x)$.
\item Für einen Typ $A(x)$ unter der Annahme $x:\mathbf{1}$ und $a:A(\ast)$
gilt $\elim_{\mathbf{1}}(a)(\ast)\equiv a$.
\end{itemize}
\end{regeln}

Ein noch minimalerer Fall ist der \begriff{leere Typ} $\emptyset$\index{$\emptyset$},
der keinen Konstruktor hat und damit nur zwei Regeln:

\begin{regeln}
\begin{itemize}
\item Es gibt den Typ $\emptyset$. 
\item Sei $A(x)$ ein Typ für $x:\emptyset$, dann gibt es $\elim_\emptyset:(x:\emptyset)\to A(x)$.
\end{itemize}
\end{regeln}

Es ist möglich, Typen als Parameter für induktive Definitionen zu verwenden.
Ein wichtiges Beispiel, das uns noch begleiten wird, ist das \begriff{Koprodukt} $A\sqcup B$\index{$A\sqcup B$}, das ein induktiver Typ mit zwei Konstruktoren ist.

\begin{regeln}
Seien $A,B$ Typen.
\begin{itemize}
\item Es gibt den Typ $A\sqcup B$.
\item Für jedes $a:A$ gibt es $\iota_1(a):A\sqcup B$.
  Und für jedes $b:B$ gibt es $\iota_2(b):A\sqcup B$.
\item Sei $P(x)$ ein Typ für $x:A\sqcup B$.
  Für $p_1:(y:A)\to P(\iota_1(y))$ und $p_2:(z:A)\to P(\iota_2(z))$
  gibt es $\elim_\sqcup(p_1,p_2):(x:A\sqcup B)\to P(x)$.
\item Sei $P(x)$ ein Typ für $x:A\sqcup B$.
  Für $p_1:(y:A)\to P(\iota_1(y))$ und $p_2:(z:A)\to P(\iota_2(z))$
  gilt $\elim_\sqcup(p_1,p_2)(\iota_1(y))\equiv p_1(y)$ für $y:A$
  und  $\elim_\sqcup(p_1,p_2)(\iota_2(z))\equiv p_1(z)$ für $z:B$.
\end{itemize}
\end{regeln}

\begin{bemerkung}
  Sei $A$ ein Typ. Es gibt Funktionen
  \begin{center}
  \begin{align*}
    \varphi: &A\to \emptyset\sqcup A &\psi:\emptyset\sqcup A \to A \\
    \varphi(a)&\colonequiv \iota_2(a) &\psi(\iota_2(a))\colonequiv a 
\end{align*}
\end{center}
Die Pattern-Matching-Definition auf der rechten Seite ist vollständig, weil wir im Fall ``$\iota_1$'' auf den leeren Typ matchen und damit null Fälle zu klären haben.
\end{bemerkung}

\subsection{Der Beweisassistent Agda}
Agda ist ein Programm, in dem wir Terme und Typen in abhängiger Typentheorie eingeben und prüfen können, ob diese den Regeln entsprechen. Agda kann man hier online testen: \url{https://agdapad.quasicoherent.io/}. Und hier findet man eine Anleitung zur Installation: \url{https://agda.readthedocs.io/en/latest/getting-started/installation.html}. Für die meisten Linux-Distributionen sollte es einfach genügend aktuelle Pakete geben. Für Windows-Nutzer (und Leute die nicht in Emacs/Vi arbeiten möchten) ist es wahrscheinlich eine gute Idee, ``VS Code'' mit dem agda-mode plugin zu verwenden.

In der ersten Übung werden wir uns Agda anschauen und mit diesen Aufgaben starten: \url{https://felix-cherubini.de/HoTT.agda}.
