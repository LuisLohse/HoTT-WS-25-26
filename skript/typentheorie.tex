Eine Gemeinsamkeit mit der Ihnen vertrauten Art Mathematik zu betreiben, ist, dass wir auch weiterhin Buchstaben verwenden, um komplexere Ausdrücke abzukürzen und Funktionen zu definieren - etwa ``$x\mapsto x+1$''. In der Typentheorie gibt es Terme, die wir auch Elemente nennen werden, und Typen. Ein Term hat stets einen Typ. Zum Beispiel werden wir mit ``$n:\N$'' später ausdrücke können, dass $n$ ein Term des Typs $\N$ der natürlichen Zahlen. ``$n:\N$'' ist ein \begriff{Urteil}.
In der Homotopietypentheorie gibt es vier grundlegende Urteile:

\begin{center}
  \begin{tabular}{ll}
    Urteil                        & Bedeutung \\
    \hline
    $ t : A$         & $t$ ist ein Term vom Typ $A$ \\
    $ A$ Typ         & $A$ ist ein Typ \\
    $ A\equiv B$     & $A$ und $B$ sind (urteils-)gleiche Typen \\
    $ t\equiv s : A$ & $t$ und $s$ sind (urteils-)gleiche Terme des Typs $A$ \\
  \end{tabular}
  \label{tab:urteile}
\end{center}

\subsection{Funktionen in einfacher Typentheorie}
Wir werden in diesem Abschnitt ein Fragment einer einfachen Typentheorie betrachten - ``einfach'' bedeutet hier, dass es sich noch nicht um eine abhängige Typentheorie handelt.
Typentheorien bestehen aus einer Liste von Regeln - unsere erste Regel ist:
\begin{center}
 Wenn $A$ und $B$ Typen sind, dann ist $A\to B$ ein Typ.
\end{center}
Regeln, die es erlauben neue Typen zu produzieren, werden auch \begriff{Typformer} genannt.
Das Urteil $f:A\to B$ bedeutet nun dass $f$ ein Term des Typs $A\to B$ ist (also eine Funktion).
Um Terme des Typs $A\to B$ zu konstruieren, muss unter der Annahme $x:A$ ein Term $b(x):B$ angegeben werden:
\begin{center}
  Ist unter der Annahme $x:A$ ein Term $b(x):B$ gegeben, so ist $x\mapsto b(x) : A\to B$.
\end{center}
Regeln die Terme konstruieren nennen wir \begriff{Konstruktoren}\footnote{In der literatur ``Introduction rules''.}.
Schließlich gibt es eine Regel, die es erlaubt Terme des Typs $A\to B$ zu \emph{verwenden}:
\begin{center}
  Seien $f:A\to B$ und $x:A$, dann gibt es einen Term $f(x):B$.
\end{center}
Regeln dieser Art werden \begriff{Eliminatoren} genannt.
\begin{beispiel}
\begin{enumerate}[(a)]
\item Für Typen $A,B,C$ gibt es stets eine Funktion $s$ des Typs
  \[
    (A\to (B\to C)) \to (B\to (A\to C))
  \]
  gegeben durch $f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
\item Wenn wir für einen Moment annehmen, wir hätten bereits einen Typ $\N$ der natürlichen Zahlen und $+:\N\to(\N\to \N)$ dann können wir die folgende Funktion definieren:
\begin{align*}
  d:&\N\to\N \\
    & x\mapsto x+x
\end{align*}
\end{enumerate}
\end{beispiel}

Im ersten Beispiel haben wir gesehen, dass sich Funktionen in zwei Argumenten durch iterierte Typformierung ``$A\to (B\to C)$'' ausdrücken lassen. Man beachte dass das nicht der gleiche Typ wie ``$(A\to B)\to C$'' ist.
\begin{konvention}
  Seien $A,B,C$ Typen. $A\to B\to C$ bezeichnet den Typ $A\to (B\to C)$.
\end{konvention}
Wir verwenden das Zeichen $\colonequiv$ für Definitionen.
Der Text im Beispiel entspricht also der Definition $s\colonequiv f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
Das Symbol $\colonequiv$ passt zusammen mit der definitionalen Gleichheit in der Homotopietypentheorie $\equiv$. Solche Gleichheiten bekommen wir mit den folgenden Regeln:
\begin{center}
  Für $b(x):B$ unter der Annahme $x:A$ und $a:A$ gilt $(x\mapsto b(x))(a)\equiv b(a)$.
\end{center}
Regeln, die auf diese Art Konstruktoren und Eliminatoren verbinden heißen \begriff{Berechnungsregeln}\footnote{In der Literatur ``computation rules''.}
Speziell für Funktionen gibt es noch die sogenannte ``$\eta$-rule'':
\begin{center}
  Für $f:A\to B$ gilt $f\equiv x\mapsto f(x)$.
\end{center}

Wir kommen nun zu unseren ersten Definitionen:
\begin{definition}
  Sei $A$ ein Typ. Dann bezeichnen wir den Term $x\mapsto x:A\to A$ mit $\id_A$.
\end{definition}

\begin{definition}
  Seien $A,B,C$ Typen. Dann ist $\circ:(B\to C)\to (A\to B) \to (A\to C)$ gegeben durch
  \[
    g\mapsto (f\mapsto (x\mapsto g(f(x))))
  \]
  Wir schreiben wie gewohnt $g\circ f$ statt $\circ(g)(f)$.
\end{definition}

\begin{bemerkung}
\begin{enumerate}
\item Für $f:A\to B$ gilt stets $f\circ \id_A\equiv f\equiv \id_B\circ f$. 
\item In den Übungen werden wir sehen: $h \circ (g\circ f)\equiv (h\circ g)\circ f$.
\end{enumerate}
\end{bemerkung}

\subsection{Abhängige Funktionen}
Wir wollen nun die Regeln des letzten Abschnitts verallgemeinern.
Dafür gibt es verschiedene Gründe. Der wichtigste ist, dass wir Prädikate in der Typentheorie haben wollen und einen verallgemeinerten Funktionstyp als $\forall$-quantor verwenden wollen.

Ein abhängiger Typ ist nichts weiter als ein Ausdruck $B(x)$, der unter der Annahme $x:A$ ein Typ ist.

\begin{beispiel}
  Wir greifen etwas vorweg um konkrete Beispiele zu geben.
  Für $n:\N$ werden wir noch einen Typ $L(n)$ der Listen der Länge $n$ von natürlichen Zahlen konstruieren. Weiter wird es später auch möglich sein, etwa den Typ der Teiler einer natürlichen Zahl zu definieren. Oder einen Typ, der genau dann Terme hat, wenn eine natürliche Zahl eine andere teilt.
\end{beispiel}

Die Regeln für Funktionstypen aus dem letzten Abschnitt lassen sich nun wie folgt für \begriff{abhängige Funktionen} verallgemeinern:

\begin{center}
\begin{tabular}{l}
  Sei für $x:A$ ein Typ $B(x)$ gegeben, dann ist $(x:A)\to B(x)$\index{$(x:A)\to B(x)$} ein Typ. \\
  Sei für $x:A$ ein Term $b(x):B(x)$ gegeben, dann ist $x\mapsto b(x) : (x:A)\to B(x)$\index{$x\mapsto b(x)$}. \\
  Für $f:(x:A)\to B(x)$ und $a:A$ gibt es $f(a):B(a)$. \\
  Sei für $x:A$ ein Term $b(x):B(x)$ gegeben und $a:A$, dann $(x\mapsto b(x))(a)\equiv b(a)$. \\
  Für $f:(x:A)\to B(x)$ ist $(x\mapsto f(x))\equiv f$.
\end{tabular}
\end{center}

Statt $(x:A)\to B(x)$ schreiben wir auch $\prod_{x:A}B(x)$.
Falls $B(x)$ konstant ein Typ $C$ ist, schreiben wir auch $A\to C$ und sind damit kompatibel zum vorangegangenen Abschnitt.
Außerdem ist es manchmal hilfreich mehr Typen anzugeben als unbedingt notwendig - zum Beispiel hilft es zur Lesbarkeit den Typ der Variable in Funktionsausdrücken anzugeben: $(x:A)\mapsto b(x)$\index{$(x:A)\mapsto b(x)$}.

\subsection{Natürliche Zahlen}
Ähnlich wie bei dem Funktionstyp beschreiben wir die natürlichen Zahlen auch darüber, wie man Elemente erzeugen und verwenden kann.
Die Formierungsregel ist denkbar einfach: Es gibt einen Typ $\N$\index{$\N$}.

Die \begriff{natürlichen Zahlen} $\N$ haben \emph{zwei} Konstruktoren:
\begin{center}
\begin{tabular}{l}
  Es gibt $0:\N$. \\
  Für jedes $n:\N$ gibt es einen Nachfolger $S(n):\N$\index{$S(n)$}.
\end{tabular}
\end{center}
Dass wir hier ``Nachfolger'' schreiben hat keine formale Bedeutung.
\begin{beispiel}
Wir können nun natürliche Zahlen angeben: $0$, $1\colonequiv S(0)$, $2\colonequiv S(1)$, \dots.
\end{beispiel}
Der Eliminator ist auf den ersten Blick vielleicht etwas undurchsichtig, wird aber sicher schnell klarer durch Beispiele:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$ und $p_S:(x:\N)\to (P(x)\to P(S(x)))$ dann gibt es
  $\elim_\N(p_0,p_S):(x:\N)\to P(x)$.
\end{center}
Wir betrachten zunächst den Fall, dass $P(x)$ konstant ein Typ $A$ ist.
Dann sind die ``Eingangsdaten'' für den Eliminator ein $a:A$ und eine Funktion $\N\to (A\to A)$.
In diesem Fall spricht man auch von \begriff{Rekursion}.
Wenn man eine Funktion $f:\N\to A$ durch Rekursion definiert, gibt man üblicherweise an, was im Fall $n\equiv 0$ passiert und wie man aus $f(n)$ den nächsten Wert $f(n+1)$ konstruiert.
Diese beiden Fälle entsprechen genau den Daten $a:A$ und $r:\N\to (A\to A)$.
\begin{beispiel}
  Wir können Verdopplung $d:\N\to \N$ von natürlichen Zahlen definieren durch:
  \[d\colonequiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))\rlap{.}\]
\end{beispiel}
Um die soeben definierte Funktion testen zu können, benötigen wir die Berechnungsregel für $\N$:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$, $p_S:(x:\N)\to (P(x)\to P(S(x)))$ und $n:\N$
  dann gelten $\elim_\N(p_0,p_S)(0)\equiv p_0$ und $\elim_\N(p_0,p_S)(S(n))\equiv p_S(n)(\elim_\N(p_0,p_S)(n))$.
\end{center}
Damit können wir nun zum Beispiel berechnen:
\begin{align*}
  d(2)&\equiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(1)) \\
      &\equiv (n\mapsto (k\mapsto S(S(k))))(1)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))) \\
      &\equiv (k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(1)) \\
      &\equiv S(S(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(0)))) \\
      &\equiv S(S((n\mapsto (k\mapsto S(S(k))))(0)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S((k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S(S(S(0)))) \\
      &\equiv 4
\end{align*}

Um definitionen übersichtlicher darzustellen, verwenden wir \begriff{Pattern-matching}:

\begin{konvention}
  Definitionen wie in obigem Beispiel schreiben wir auch in der folgenden Form
  \begin{align*}
    d(0)&\colonequiv 0 \\
    d(S(n))&\colonequiv S(S(d(n))) 
  \end{align*}
  - wenn die Übersetzung in Eliminatoraufrufe klar ist.
\end{konvention}

Mit $A\equiv \N\to\N$ wählen und die Addition definieren.
\begin{definition}
  Die Funktion $+:\N\to (\N\to \N)$ ist gegeben durch
  \begin{align*}
    +:&\N\to (\N\to \N) \\
      +(0)&\colonequiv \id_\N \\
     +(S(n))&\colonequiv k\mapsto S(+(n)(k))
  \end{align*}
  Wir schreiben wie gewohnt auch ``$a+b$''.
\end{definition}

\subsection{Der Beweisassistent Agda}
Agda ist ein Programm, in dem wir Terme und Typen in abhängiger Typentheorie eingeben und prüfen können, ob diese den Regeln entsprechen. Agda kann man hier online testen: \url{https://agdapad.quasicoherent.io/}. Und hier findet man eine Anleitung zur Installation: \url{https://agda.readthedocs.io/en/latest/getting-started/installation.html}. Für die meisten Linux-Distributionen sollte es einfach genügen aktuelle Pakete geben.
